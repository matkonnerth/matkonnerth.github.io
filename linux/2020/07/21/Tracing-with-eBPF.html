<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>UDP packet tracing with eBPF | matkonnerth</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="UDP packet tracing with eBPF" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Introduction" />
<meta property="og:description" content="Introduction" />
<link rel="canonical" href="matkonnerth.github.io/linux/2020/07/21/Tracing-with-eBPF.html" />
<meta property="og:url" content="matkonnerth.github.io/linux/2020/07/21/Tracing-with-eBPF.html" />
<meta property="og:site_name" content="matkonnerth" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-07-21T07:54:21+00:00" />
<script type="application/ld+json">
{"description":"Introduction","url":"matkonnerth.github.io/linux/2020/07/21/Tracing-with-eBPF.html","@type":"BlogPosting","headline":"UDP packet tracing with eBPF","dateModified":"2020-07-21T07:54:21+00:00","datePublished":"2020-07-21T07:54:21+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"matkonnerth.github.io/linux/2020/07/21/Tracing-with-eBPF.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="matkonnerth.github.io/feed.xml" title="matkonnerth" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">matkonnerth</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">UDP packet tracing with eBPF</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-07-21T07:54:21+00:00" itemprop="datePublished">Jul 21, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="introduction">Introduction</h1>

<p>This blog post gives an overview of how to trace down the way of an udp packet from calling sendto in userspace till the packet is finally transmitted.</p>

<h2 id="ebpf">eBPF</h2>
<p>eBPF is the abbreviation for extended Berkeley Packet Filter. For tracing eBPF is used. eBPF is an in kernel virtual machine and fulfills various use cases, for example network packet filtering or tracing. There are various ressources about eBPF available, I’ve listed some of them in the ressources section.</p>

<h3 id="bpftrace">BPFTrace</h3>
<p><img src="http://www.brendangregg.com/blog/images/2018/bpftrace_internals_2018.png" alt="bpftrace overview" /></p>

<p>For writing and downloading to the kernel BPF the trace program, bpftrace is used. BPFTrace programs are written in a high level language (if you consider C a high level language ;))</p>

<h2 id="probe-types">Probe types</h2>

<p>eBPF supports different probe types, here is a list of the important ones:</p>
<ul>
  <li>tracepoints: are static, compiled into the kernel. System calls are instrumented with them.</li>
  <li>kprobe: are dynamic, kernel functions can be instrumented at runtime with them.</li>
  <li>uprobe: like kprobe also dynamic, but for user space</li>
  <li>USDT (user level static defined tracing): a user space version of tracepoints</li>
</ul>

<p>Dynamic instrumentation (like kprobes and uprobes) costs zero overhead, when not in use.</p>

<h3 id="looking-up-probes">Looking up probes</h3>

<p>Probes can be looked up with <em>bpftrace -lv “*nameOfProbe*“</em> for example:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>bpftrace <span class="nt">-lv</span> <span class="s2">"*sendto*"</span>

tracepoint:syscalls:sys_enter_sendto
    int __syscall_nr<span class="p">;</span>
    int fd<span class="p">;</span>
    void <span class="k">*</span> buff<span class="p">;</span>
    size_t len<span class="p">;</span>
    unsigned int flags<span class="p">;</span>
    struct sockaddr <span class="k">*</span> addr<span class="p">;</span>
    int addr_len<span class="p">;</span>
tracepoint:syscalls:sys_exit_sendto
    int __syscall_nr<span class="p">;</span>
    long ret<span class="p">;</span>
kprobe:__sys_sendto</code></pre></figure>

<p>Tracepoints also return there parameters.</p>

<h2 id="prerequisites">Prerequisites</h2>

<p>eBPF for this examples requires a linux kernel &gt;=4.x compiled with this config options, I’ve run the examples on a 4.19 kernel. There is a <a href="https://github.com/iovisor/bpftrace/tree/master/scripts">script</a> called <em>check_kernel_features</em> in  whick checks if the requirements are fullfiled.</p>

<h1 id="way-of-an-udp-packet-through-kernel">Way of an UDP packet through kernel</h1>

<h2 id="generating-traffic">Generating traffic</h2>
<p>For generating udp traffic, <a href="https://github.com/open62541/open62541/tree/master/examples/pubsub">open62541</a> is used. OPC UA supports the publish-subscribe pattern over different encodings and transport, one of them is binary encoding over udp. I’ve used the tutorial_pubsub_publish for generating udp packets. Simply clone the repo and build with examples enabled and start the publisher.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">git clone https://github.com/open62541/open62541.git
<span class="nb">cd </span>open62541
<span class="nb">mkdir </span>build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
cmake <span class="nt">-DUA_BUILD_EXAMPLES</span><span class="o">=</span>ON <span class="nt">-DUA_ENABLE_PUBSUB</span><span class="o">=</span>ON ..
make <span class="nt">-j</span>
bin/examples/tutorial_pubsub_publish</code></pre></figure>

<p>So, now the publisher should run. We can inspect this with the perf command and taking a look on the system calls of the publisher:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">pidof tutorial_pubsub_publish
20488
<span class="nb">sudo </span>perf trace <span class="nt">-p</span> 20488
- 949.690 <span class="o">(</span>50.166 ms<span class="o">)</span>: <span class="k">select</span><span class="o">(</span>n: 6, inp: 0x7ffc4b80af50, exp: 0x7ffc4b80aed0, tvp: 0x7ffc4b80aeb0<span class="o">)</span> <span class="o">=</span> 0 Timeout
- 999.875 <span class="o">(</span> 0.005 ms<span class="o">)</span>: clock_gettime<span class="o">(</span>which_clock: MONOTONIC_RAW, tp: 0x7ffc4b80ae20          <span class="o">)</span> <span class="o">=</span> 0
- 999.886 <span class="o">(</span> 0.003 ms<span class="o">)</span>: clock_gettime<span class="o">(</span>which_clock: MONOTONIC_RAW, tp: 0x7ffc4b80b040          <span class="o">)</span> <span class="o">=</span> 0
- 999.894 <span class="o">(</span> 0.004 ms<span class="o">)</span>: clock_gettime<span class="o">(</span>which_clock: MONOTONIC_RAW, tp: 0x7ffc4b80b040          <span class="o">)</span> <span class="o">=</span> 0
- 999.931 <span class="o">(</span> 0.083 ms<span class="o">)</span>: sendto<span class="o">(</span>fd: 3&lt;socket:[452663]&gt;, buff: 0x7ffc4b80acb0, len: 39, addr: 0x55cab43df720, addr_len: 128<span class="o">)</span> <span class="o">=</span> 39</code></pre></figure>

<p>We see that we get some clock_gettime, a select and the sendto systemcall.
What we are interested, is the latency of the sendto systemcall, that means the delay from the sendto call and when the datagram leaves the network interface. For that, we have to know a little bit about how linux kernel networking works.</p>

<p>High level view on network data and possible tracepoints</p>
<ol>
  <li>user space: UA_WriterGroup_publishCallback</li>
  <li>system call (sendto, sendmsg, …)                                                                       tracepoint:syscalls:sys_enter_sendto</li>
  <li>socket subsystem</li>
  <li>Protocol layers, in our case UDP and IP                                                                  kprobe:ip_send_skb</li>
  <li>Device agnostic layer</li>
  <li>device drivers transmit function is called</li>
  <li>data is passed on to the queue discipline (qdisc)</li>
  <li>data is transmitted directly or it is queued and sent during NET_TX softirq</li>
  <li>once transmission is complete, net device raises interrupt to signal transmit completion</li>
  <li>packet data is freed                                                                                     tracepoint:skb:consume_skb</li>
</ol>

<h2 id="bpftrace-program">bpftrace program</h2>

<p>BPFTrace is used to write this latency tracing program, it can be found <a href="https://github.com/matkonnerth/bpfExamples/blob/master/udp_sendto.bt">here</a></p>

<p>sendto and ip_send_skb are called in process context, consume_skb is called in context of an kernel thread. We save the time when the sendto system call is called, associate it with the socket buffer in kprobe:ip_send_skb and calculate the difference in tracepoint:skb:consume_skb.</p>

<h1 id="ressources">Ressources</h1>
<ul>
  <li><a href="https://github.com/matkonnerth/bpfExamples/blob/master/udp_sendto.bt">the bpftrace program for udp_sendto latency tracing</a></li>
  <li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md">BPFTrace reference guide</a></li>
  <li><a href="https://github.com/iovisor/bpftrace">bpftrace source</a></li>
  <li><a href="http://www.brendangregg.com/bpf-performance-tools-book.html">BPF Performance tools from Brendan Gregg</a></li>
</ul>

  </div><a class="u-url" href="/linux/2020/07/21/Tracing-with-eBPF.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">matkonnerth</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">matkonnerth</li><li><a class="u-email" href="mailto:matkonnerth@gmail.com">matkonnerth@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/matkonnerth"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">matkonnerth</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>private blog of matkonnerth.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
